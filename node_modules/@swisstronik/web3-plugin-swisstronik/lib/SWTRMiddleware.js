"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SWTRMiddleware = void 0;
const utils_1 = require("@swisstronik/utils");
const web3_utils_1 = require("web3-utils");
class SWTRMiddleware {
    constructor(getNodePublicKey) {
        this.getNodePublicKey = getNodePublicKey;
        this.cachedRequestById = {};
        this.isDataEncrypted = {};
    }
    async processTransaction(transaction) {
        if (transaction.data && transaction.to) {
            let nodePublicKey = await this.getNodePublicKey();
            let [encryptedData] = (0, utils_1.encryptDataFieldWithPublicKey)(nodePublicKey, transaction.data);
            transaction.data = encryptedData;
            this.isDataEncrypted[encryptedData] = true;
        }
        return transaction;
    }
    async processRequest(request) {
        if (["eth_estimateGas", "eth_call"].includes(request.method) &&
            Array.isArray(request.params)) {
            const param = request.params[0];
            if (param.data && param.to && !this.isDataEncrypted[param.data]) {
                const nodePublicKey = await this.getNodePublicKey();
                const [encryptedData, encryptionKey] = (0, utils_1.encryptDataFieldWithPublicKey)(nodePublicKey, param.data);
                this.cachedRequestById[request.id?.toString()] = {
                    method: request.method,
                    nodePublicKey,
                    encryptionKey,
                };
                param.data = encryptedData;
                this.isDataEncrypted[encryptedData] = true;
            }
        }
        return Promise.resolve(request);
    }
    async processResponse(response, options) {
        let responseObj = { ...response };
        const { result, id } = responseObj;
        const cachedRequest = this.cachedRequestById[id?.toString()];
        if (!web3_utils_1.jsonRpc.isBatchResponse(responseObj) &&
            cachedRequest?.method === "eth_call" &&
            result) {
            const decrypted = (0, utils_1.decryptNodeResponseWithPublicKey)(cachedRequest.nodePublicKey, result, cachedRequest.encryptionKey);
            delete this.cachedRequestById[id?.toString()];
            responseObj = {
                ...responseObj,
                result: (0, web3_utils_1.format)({ format: "bytes" }, decrypted),
            };
        }
        return Promise.resolve(responseObj);
    }
}
exports.SWTRMiddleware = SWTRMiddleware;
//# sourceMappingURL=SWTRMiddleware.js.map